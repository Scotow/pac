// Modules.
const request = require('request-promise-native').defaults({
    jar: true,
    json: true
});

// Environment variables.
require('dotenv').config();

if(!process.env.PAC_USERNAME) throw new Error('Please set PAC_USERNAME environment variable.');
if(!process.env.PAC_PASSWORD) throw new Error('Please set PAC_PASSWORD environment variable.');

// Setup.
const BLOCK_SIZE = 16;
// ASCII chars ordered by use probability.
const CHARS_PROBABILITY = [32, 101, 116, 97, 111, 105, 110, 115, 114, 104, 100, 108, 117, 99, 109, 102, 121, 119, 103, 112, 98, 118, 107, 120, 113, 106, 122, 69, 84, 65, 79, 73, 78, 83, 82, 72, 68, 76, 85, 67, 77, 70, 89, 87, 71, 80, 66, 86, 75, 88, 81, 74, 90, 49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 40, 41, 58, 46, 34, 59, 61, 64, 124, 95, 126, 125, 123, 96, 94, 93, 92, 91, 63, 62, 60, 47, 45, 44, 43, 42, 39, 38, 37, 36, 35, 33, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 255, 254, 253, 252, 251, 250, 249, 248, 247, 246, 245, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 230, 229, 228, 227, 226, 225, 224, 223, 222, 221, 220, 219, 218, 217, 216, 215, 214, 213, 212, 211, 210, 209, 208, 207, 206, 205, 204, 203, 202, 201, 200, 199, 198, 197, 196, 195, 194, 193, 192, 191, 190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 178, 177, 176, 175, 174, 173, 172, 171, 170, 169, 168, 167, 166, 165, 164, 163, 162, 161, 160, 159, 158, 157, 156, 155, 154, 153, 152, 151, 150, 149, 148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 135, 134, 133, 132, 131, 130, 129, 128, 127];

// Utils.

// Terminal utils.
const terminal = {
    clear: () => write('\033[2J'),
    hide: () => write('\x1b[?25l'),
    show: () => write('\x1b[?25h'),
    moveTo: (x, y) => write(`\x1b[${y + 1};${x + 1}H`),
    white: () => write('\x1b[97m'),
    red: () => write('\x1b[31m'),
    yellow: () => write('\x1b[33m'),
    green: () => write('\x1b[32m'),
    blue: () => write('\x1b[36m'),
    reset: () => write('\x1b[?25h\x1b[0m')
};

function write(data) {
    process.stdout.write(data);
}

// Move cursor to block/byte table cell.
function moveToByte(block, byte) {
    terminal.moveTo(String(block - 1).length + 3 + byte * 3, block);
}

// Format an integer as hex with optional padding.
function toHex(number) {
    return ('0' + number.toString(16).toUpperCase()).slice(-2);
}

// Split message in BLOCK_SIZE blocks.
function splitMessage(message) {
    const messageBlocks = [Buffer.from(message.IV, 'base64')];

    const textBuffer = Buffer.from(message.ciphertext, 'base64');
    for(let i = 0; i < textBuffer.length / BLOCK_SIZE; i++) {
        messageBlocks.push(textBuffer.slice(i * BLOCK_SIZE, (i + 1) * BLOCK_SIZE));
    }

    return messageBlocks;
}

// Display message blocks initiated with red.
function initDisplay(message) {
    // Clear screen.
    terminal.clear();
    terminal.hide();
    terminal.moveTo(0, 0);

    // Display IV in blue.
    terminal.white();
    write('IV: ');
    terminal.blue();
    write(message[0].toString('hex').match(/.{2}/g).join(' ').toUpperCase() + '\n');

    // Display message chunks.
    for(let i = 0; i < message.length - 1; i++) {
        terminal.white();
        write(`${i}${' '.repeat(2 - String(i).length)}: `);
        terminal.red();
        write('00 '.repeat(BLOCK_SIZE) + '\n');
    }
}

// Xor two blocks.
function xor(a, b) {
    const length = Math.max(a.length, b.length);
    const buffer = Buffer.allocUnsafe(length);

    for(let i = 0; i < length; ++i) {
        buffer[i] = a[i] ^ b[i];
    }

    return buffer;
}

// Session.
function openSession() {
    return request.post({
        url: 'http://pac.fil.cool/uglix/bin/login',
        body: {
            user: process.env.PAC_USERNAME,
            password: process.env.PAC_PASSWORD
        }
    });
}

// Fetch a new monitor-settings encrypted message.
function generateMessage() {
    return request.get('http://pac.fil.cool/uglix/sbin/monitor-settings');
}

// Send a encrypted message to the oracle.
async function oracle(block, iv) {
    const response = await request.post({
        url: 'http://pac.fil.cool/uglix/sbin/monitor-settings',
        resolveWithFullResponse: true,
        simple: false,
        body: {
            IV: iv.toString('base64'),
            ciphertext: block.toString('base64')
        }
    });

    // Check http status code. Pray for no 503 error.
    response.body !== 'Padding error' && response.statusCode !== 200 && console.log(response.statusCode, response.body);
    return response.statusCode === 200;
}

// See equations.txt for more information about the xor used in this method.
async function decryptByte(block, previous, index, decrypted, blockIndex, preferedBytes = CHARS_PROBABILITY) {
    const iv = Buffer.allocUnsafe(BLOCK_SIZE);

    // Set previous padding bytes.
    for(let i = BLOCK_SIZE - 1; i > index; i--) {
        iv[i] = (BLOCK_SIZE - index) ^ decrypted[i] ^ previous[i];
    }

    // Use bytes order to speed things up.
    let bytes = preferedBytes.map(e => e ^ (BLOCK_SIZE - index) ^ previous[index]);

    for(let testing of bytes) {
        // Value being testing (re-aranged).
        const value = (BLOCK_SIZE - index) ^ previous[index] ^ testing;

        // Display current testing byte.
        moveToByte(blockIndex, index);
        terminal.yellow();
        write(toHex(value));

        // Value being testing.
        iv[index] = testing;

        // If oracle return an ok padding.
        if(await oracle(block, iv)) {
            // Change byte color.
            moveToByte(blockIndex, index);
            terminal.green();
            write(toHex(value));

            // Set byte value in the block.
            decrypted[index] = value;
            return;
        }
    }
}

async function decryptBlock(block, previous, blockIndex) {
    const decrypted = Buffer.allocUnsafe(BLOCK_SIZE);

    // Decrypt each bytes.
    for(let i = BLOCK_SIZE - 1; i >= 0; i--) {
        await decryptByte(block, previous, i, decrypted, blockIndex);
    }
    return decrypted;
}

async function decryptLastBlock(block, previous, blockIndex) {
    const decrypted = Buffer.allocUnsafe(BLOCK_SIZE);

    // Get last byte of the block (padding value) prioritizing 0x1-0x16 bytes.
    await decryptByte(block, previous, BLOCK_SIZE - 1, decrypted, blockIndex, [...Array(BLOCK_SIZE + 1).keys()].slice(1));

    // Try each next bytes that are supposed to be padding.
    for(let i = BLOCK_SIZE - 2; i >= BLOCK_SIZE - decrypted[BLOCK_SIZE - 1]; i--) {
        await decryptByte(block, previous, i, decrypted, blockIndex, [decrypted[BLOCK_SIZE - 1], ...CHARS_PROBABILITY]);
    }

    // Try remaining bytes.
    for(let i = BLOCK_SIZE - decrypted[BLOCK_SIZE - 1] - 1; i >= 0; i--) {
        await decryptByte(block, previous, i, decrypted, blockIndex);
    }

    return decrypted;
}

// Main.
async function exploit() {
    // Open user session.
    await openSession();

    // Format message chunks.
    const message = splitMessage(await generateMessage());
    initDisplay(message);

    // Exploit each block with special loop for the last block.
    const decrypted = await Promise.all([
        ...message.slice(1, -1).map((e, i) => {
            return decryptBlock(message[i + 1], message[i], i + 1);
        }),
        decryptLastBlock(message[message.length - 1], message[message.length - 2], message.length - 1)
    ]);

    // Remove padding.
    decrypted[decrypted.length - 1] = decrypted[decrypted.length - 1].slice(0, BLOCK_SIZE - decrypted[decrypted.length - 1][BLOCK_SIZE - 1]);

    // Reset terminal.
    terminal.reset();
    terminal.moveTo(0, message.length + 1);

    // Display message.
    console.log(Buffer.concat(decrypted).toString('utf8'));
}

process.on('SIGINT', () => {
    // Reset terminal.
    terminal.reset();
    process.exit(1);
});

// Run.
exploit()
.catch(error => console.error(error.message));
