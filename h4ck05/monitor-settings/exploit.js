// Modules.
const request = require('request-promise-native').defaults({
    jar: true,
    json: true
});

// Environment variables.
require('dotenv').config();

if(!process.env.PAC_USERNAME) throw new Error('Please set PAC_USERNAME environment variable.');
if(!process.env.PAC_PASSWORD) throw new Error('Please set PAC_PASSWORD environment variable.');

// Setup.
const BLOCK_SIZE = 16;

const MESSAGE = {
    "IV": "6ridwGS/HKgWPCQL0GjwEA==",
    "ciphertext": "75Y+BjRx+3ehP5HDUZdMPQe6g4m+lCE2XzhUkRNOGWOxGQQ4T6rFl3U2SOIVJ/NRghXdMGMA52poiYnRmmd/90JaDBF3/FzIWyl7woezWc68ZTxRHrM8UvQntf3MZhPsa3PeXSO2JXpXdXsL1yrYNxSNYUq5xVERfs63mXof1Naw3ys6tNAzrI57Mx25FJnGDmPoVQDtL6VZq2asYOBYjg=="
};

// Utils.
function splitMessage(message) {
    const messageBlocks = [Buffer.from(message.IV, 'base64')];

    const textBuffer = Buffer.from(message.ciphertext, 'base64');
    for(let i = 0; i < textBuffer.length / BLOCK_SIZE; i++) {
        messageBlocks.push(textBuffer.slice(i * BLOCK_SIZE, (i + 1) * BLOCK_SIZE));
    }

    return messageBlocks;
}

function xor(a, b) {
    const length = Math.max(a.length, b.length);
    const buffer = Buffer.allocUnsafe(length);

    for(let i = 0; i < length; ++i) {
        buffer[i] = a[i] ^ b[i];
    }

    return buffer;
}

// Session.
function openSession() {
    return request.post({
        url: 'http://pac.fil.cool/uglix/bin/login',
        body: {
            user: process.env.PAC_USERNAME,
            password: process.env.PAC_PASSWORD
        }
    });
}

// Message.
function generateMessage() {
    return request.get('http://pac.fil.cool/uglix/sbin/monitor-settings');
}

async function oracle(block, iv) {
    const response = await request.post({
        url: 'http://pac.fil.cool/uglix/sbin/monitor-settings',
        resolveWithFullResponse: true,
        simple: false,
        body: {
            IV: iv.toString('base64'),
            ciphertext: block.toString('base64')
        }
    });

    response.body !== 'Padding error' && response.statusCode !== 200 && console.log(response.statusCode, response.body);
    return response.statusCode === 200;
}

async function decryptByte(block, previous) {
    const iv = Buffer.allocUnsafe(BLOCK_SIZE);

    for(let i = 0; i < 256; i++, iv[BLOCK_SIZE - 1]++) {
        process.stdout.write('.');
        if(await oracle(block, iv)) {
            console.log(previous[BLOCK_SIZE - 1] ^ iv[BLOCK_SIZE - 1]);
            return previous[BLOCK_SIZE - 1] ^ iv[BLOCK_SIZE - 1];
        }
    }

    return false;
}

async function decryptByte2(block, previous) {
    const iv = Buffer.allocUnsafe(BLOCK_SIZE);
    iv[BLOCK_SIZE - 1] = block[BLOCK_SIZE - 1] ^ 0x02;

    for(let i = 0; i < 256; i++, iv[BLOCK_SIZE - 2]++) {
        // console.log(iv);
        process.stdout.write('.');
        if(await oracle(block, iv)) {
            console.log(previous[BLOCK_SIZE - 2] ^ iv[BLOCK_SIZE - 2]);
            return previous[BLOCK_SIZE - 2] ^ iv[BLOCK_SIZE - 2];
        }
    }

    return false;
}

async function decryptBlock(block, previous) {

}

// Main.
async function exploit() {
    // Open user session.
    await openSession();

    const message = splitMessage(await generateMessage());

    // console.log(await decryptByte(message[message.length - 1], message[message.length - 2]));
    console.log(await decryptByte2(message[message.length - 1], message[message.length - 2]));

    // console.log(message[0]);
    // console.log(message[0][0] ^ 1);
}

exploit();
